# 什么是OOP

> OOP 面向对象编程

[wiki上的解释](https://en.wikipedia.org/wiki/Object-oriented_programming)

看完这个解释，你的脑海中会有这些词“class","object","instance","encapsulation","inheritance","polymorphism"，这些词的定义你也能从wiki中找到准确的描述。那么OOP就可以定义为使用这些概念进行设计/编码的一种方式。

OOP字面意义是“面向对象编程”，但是其中最重的一些部分，我认为不只是“对象”这个概念。通过阅读一些书籍与项目实践，我认为更为重要的是"encapsulation","inheritance","polymorphism"这三个概念。“对象”这个概念只是为了实现前面这三个概念而提出的。本质目标是利用这三个概念（"encapsulation","inheritance","polymorphism"）进行设计/编码。

下面对这个三个概念分别进行说明/讨论

## encapsulation
封装: 将数据与行为组合在一起，只将希望被外界看到、访问到的数据或行为暴露，其他内容全部隐藏起来，就叫一次封装。

支持OOP的语言，为了能够实现这个概念，提出了class 关键字，一个class定义了一组数据（属性）与一组行为（方法），并对数据或行为的访问类型提供了几种选择（private,protected,public）。

## inheritance
继承：一个B集合（包含数据和行为）成为另一个A集合（包含数据和行为）的超集，就叫B与A是继承关系，或者叫B继承于A。

支持OOP的语言，为了实现这个概念，提出了extends关键字，extends 针对class 。

## polymorphism
多态：相同的调用，由于被调用的对象继承关系不同，展现出不同行为状态。例如一个人使用“工具” - “打开” 箱子，这个调用工具打开箱子的展现行为，取决于何种“工具”，如果是锤子，就是砸开，如果是铁钎，就是撬开。无论锤子还是铁钎，在人看来都是工具，都具有“打开箱子“这个功能。

支持OOP的语言，为了实现这个概念，提出了abstract class、interface 关键字。



使用以上概念进行设计/编码的时候，要尽量遵循OOP下的设计原则（这些原则是为更好、更容易的实现理念而总结出的）:

wiki解释： [OOP-SOLID-wiki](https://en.wikipedia.org/wiki/SOLID)

一共是5条原则，Single-responsibility principle (srp) Open–closed principle(ocp) Liskov substitution principle(lsp) Interface segregation principle(isp) Dependency inversion principle(dip) ，但是我不打算全部讨论，只想说其中三个：

> 为了讨论这三个原则，我使用一个例子来说明这三个原则。例子：一个人，使用不同的工具去打开宝箱。

## SRP
单一原因修改原则：一个代码模块仅应该服务于一类决策者，也即一个代码模块仅应该受一个决策者的变动而发生改变。

一把锤子，一般高端的锤子，在手握把的地方会放一个橡胶质地的握柄套，锤身和握柄套这两部分是分开生产，则锤身生产者只需要考虑硬度、长度、耐腐蚀度这些和砸东西相关的参数，也仅因为这些参数来修改锤身的设计，握把套的生产者则考虑舒适度、缓冲度、摩擦力这些因素去设计握把套。这样两个部分的专注度高度专一，才可能有好用的锤子生产出来。否则，一会儿考虑砸东西要好用，一会儿考虑握着要舒适，增加了设计的复杂度。

## OCP
对扩展开放，对修改关闭：一个人使用工具开箱子，我们希望人可以使用多种工具进行开箱子这个行为。或者说不同箱子需要不同的工具打开。那么理想情况是我们只是需要买新工具就行了，不需要对人进行培训。这就是对扩展（买新工具）开放，对修改关闭（对人进行培训）。

## DIP
依赖倒置：上面说的人买了新工具以后，不想对人进行培训就能使用不同的工具进行开箱子，但事实是锤子要砸，撬棍要敲，这是不同的使用方式，如果是一个原始人，他可能一开始学会了锤子的使用方法，后面还要学撬棍的使用，这是我们不希望的局面，因为撬棍可能卖不出去了，没有人想学撬棍的使用方法。这时候，我们分析一下人和工具的依赖关系：人 – 依赖于 – 锤子、人 – 依赖于 – 撬棍，那么如果我们增加一个装置--开箱器–要求：每个工具上有个按钮，按下按钮工具自己去开箱子：锤子上有个按钮，按下后疯狂的砸箱子；撬棍上也有这个按钮，按下后疯狂的撬箱子。然后每个人在挑选工具（锤子、撬棍）的时候，工具上写了开箱器。那么每个人拿到开箱器以后，直接按下按钮，就可以开箱子了！人根本不需要关系底层是个锤子还是撬棍。这时候我们分析下现在的依赖关系 ，锤子/撬棍 –> 依赖于 -->开箱器<--依赖于<--人 ,人和锤子/撬棍依赖关系倒置了！

> 其实，可以简单理解为：要保持A的稳定不受B影响，只需要让B依赖于A即可。

# 为什么要使用OOP进行设计和编码
上面了解了“什么是OOP”，那么我们为什么要用 OOP来设计和编码呢？

回答这个问题之前，我们先来思考另一个问题：我们作为程序员（我更喜欢软件工程师这称呼），我们的主要工作目标是什么？

1. 编写代码实现PM的需求？对，但是不足够
2. 在1的基础上，让我们的系统对于以后的需求能够更方便、快速的实现？对，但是不够具体，与编码的关系没有具体的结合点
3. 要想实现2，我们需要建设或维持我们的系统在进行功能增加的时候，仅需要编写新功能的代码实现，少量（最好一点不需要）修改已有代码。同时，每个被修改的代码模块，应该尽量简短，功能明确、单一，修改起来不会有与本次修改目的相悖的副作用。每个模块具备测试/调试越方便越好。

> 我希望我们能达成关于程序员的工作目标的共识，否则就没有必要继续看下去了。

ok,在这个“工作目标”的共识下，我们要通过一些工程手段，来实现这个目标：**实现预计功能，保证系统可以快速、方便的添加新功能，保证系统内的各部分的可测试性**。

1. 增加新功能是，仅需要编写新功能的代码，少量或不修改已有代码:显然OCP原则就是为这个目标而诞生的。当然，设计的时候还需要配合DIP原则将依赖关系倒置。
2. 功能明确、单一: OOP的SRP原则，各模块单元遵循SRP原则，自然就是一个功能明确、单一的代码模块。
3. 保证系统内部的各部分可测试性：遵循srp原则的设计使得每个模块功能单一、明确，测试用例编写方便，遵循isp原则的设计使得每个模块的依赖关系可以方便的使用mock class进行上桩，极大提升了可测试性，降低了测试难度。

> 其实，我们的主要工作目标就是“管理系统内的依赖关系”，从而保护核心逻辑的稳定。
